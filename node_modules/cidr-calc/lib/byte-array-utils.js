"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteArrayUtils = void 0;
var ByteArrayUtils = /** @class */ (function () {
    function ByteArrayUtils() {
    }
    ByteArrayUtils.plusOne = function (bytes) {
        var result = bytes.slice(0);
        for (var i = result.length - 1; i >= 0; --i) {
            ++result[i];
            if (result[i] <= 0xff) {
                break;
            }
            else {
                result[i] = 0;
            }
        }
        return result;
    };
    ByteArrayUtils.minusOne = function (bytes) {
        var result = bytes.slice(0);
        for (var i = result.length - 1; i >= 0; --i) {
            if (result[i] > 0) {
                --result[i];
                break;
            }
            else {
                result[i] = 0xff;
            }
        }
        return result;
    };
    ByteArrayUtils.compare = function (bytes1, bytes2) {
        var byteCount = this.validateSameSizeAndGetSize(bytes1, bytes2);
        for (var i = 0; i < byteCount; ++i) {
            if (bytes1[i] > bytes2[i]) {
                return 1;
            }
            else if (bytes1[i] < bytes2[i]) {
                return -1;
            }
        }
        return 0;
    };
    ByteArrayUtils.validateSameSizeAndGetSize = function (bytes1, bytes2) {
        if (bytes2.length !== bytes1.length) {
            throw new Error('Byte arrays need to have the same size');
        }
        return bytes1.length;
    };
    ByteArrayUtils.validate = function (bytes, byteCount) {
        if (!bytes || bytes.length !== byteCount || !bytes.every(function (b) { return (b & 0xffffff00) === 0; })) {
            throw new Error('Invalid byte array');
        }
    };
    ByteArrayUtils.bytePairToHex = function (b1, b2) {
        return (((b1 & 0xff) << 8) | (b2 & 0xff)).toString(16);
    };
    ByteArrayUtils.createMasks = function (byteCount, prefixLen) {
        // [b0,      b1,      ..., bLast,   ...]
        //  11111111 11111111 ...  11111000 ...
        var masks = new Array(byteCount);
        var lastByteIndex = prefixLen >> 3;
        for (var i = 0; i < byteCount; ++i) {
            if (i < lastByteIndex) {
                masks[i] = 0xff;
            }
            else if (i === lastByteIndex) {
                masks[i] = (0xff00 >> (prefixLen & 7)) & 0xff;
            }
            else {
                masks[i] = 0;
            }
        }
        return masks;
    };
    ByteArrayUtils.findPrefixLengthOfMaxStartingCidr = function (startIpBytes, endIpBytes) {
        var bitCount = this.validateSameSizeAndGetSize(startIpBytes, endIpBytes) * 8;
        var addrHostBits = this.numberOfTrailingZeros(startIpBytes);
        var hostBitsMaxAllowed = bitCount - this.numberOfLeadingEq(startIpBytes, endIpBytes);
        if (this.numberOfTrailingOnes(endIpBytes) < hostBitsMaxAllowed) {
            --hostBitsMaxAllowed;
        }
        return bitCount - Math.min(addrHostBits, hostBitsMaxAllowed);
    };
    ByteArrayUtils.numberOfLeadingEq = function (bytes1, bytes2) {
        var byteCount = this.validateSameSizeAndGetSize(bytes1, bytes2);
        var totalCount = 0;
        for (var i = 0; i < byteCount; ++i) {
            var xorResult = bytes1[i] ^ bytes2[i];
            var count = this.numberOfLeadingZerosInByte(xorResult);
            totalCount += count;
            if (count < 8) {
                break;
            }
        }
        return totalCount;
    };
    ByteArrayUtils.numberOfTrailingZeros = function (bytes) {
        var totalCount = 0;
        for (var i = bytes.length - 1; i >= 0; --i) {
            var count = this.numberOfTrailingZerosInByte(bytes[i]);
            totalCount += count;
            if (count < 8) {
                break;
            }
        }
        return totalCount;
    };
    ByteArrayUtils.numberOfTrailingOnes = function (bytes) {
        var totalCount = 0;
        for (var i = bytes.length - 1; i >= 0; --i) {
            var count = this.numberOfTrailingZerosInByte(~bytes[i] & 0xff);
            totalCount += count;
            if (count < 8) {
                break;
            }
        }
        return totalCount;
    };
    ByteArrayUtils.numberOfLeadingZerosInByte = function (b) {
        if (b === 0) {
            return 8;
        }
        var n = 1;
        if (b >> 4 === 0) {
            n += 4;
            b <<= 4;
        }
        if (b >> 6 === 0) {
            n += 2;
            b <<= 2;
        }
        n -= b >> 7;
        return n;
    };
    ByteArrayUtils.numberOfTrailingZerosInByte = function (b) {
        if (b === 0) {
            return 8;
        }
        var n = 7;
        var y;
        y = (b << 4) & 0xff;
        if (y !== 0) {
            n -= 4;
            b = y;
        }
        y = (b << 2) & 0xff;
        if (y !== 0) {
            n -= 2;
            b = y;
        }
        return n - (((b << 1) & 0xff) >> 7);
    };
    return ByteArrayUtils;
}());
exports.ByteArrayUtils = ByteArrayUtils;
