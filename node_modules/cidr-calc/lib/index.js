"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.IpRange = exports.Cidr = exports.Ipv6Address = exports.Ipv4Address = exports.IpAddress = void 0;
var byte_array_utils_1 = require("./byte-array-utils");
var ip_notation_utils_1 = require("./ip-notation-utils");
var IpAddress = /** @class */ (function () {
    function IpAddress(bytes) {
        this.bytes = bytes.slice(0);
    }
    IpAddress.of = function (ip) {
        return IpParseUtils.fromString(ip);
    };
    IpAddress.fromByteArray = function (bytes) {
        return IpParseUtils.fromByteArray(bytes);
    };
    IpAddress.prototype.toByteArray = function () {
        return this.bytes.slice(0);
    };
    IpAddress.prototype.next = function () {
        return IpAddress.fromByteArray(byte_array_utils_1.ByteArrayUtils.plusOne(this.toByteArray()));
    };
    IpAddress.prototype.prev = function () {
        return IpAddress.fromByteArray(byte_array_utils_1.ByteArrayUtils.minusOne(this.toByteArray()));
    };
    IpAddress.prototype.compareTo = function (other) {
        if (this.version() !== other.version()) {
            throw new Error('Only IpAddresses of the same version can be compared');
        }
        return byte_array_utils_1.ByteArrayUtils.compare(this.bytes, other.bytes);
    };
    IpAddress.prototype.toString = function () {
        return this.shortNotation();
    };
    return IpAddress;
}());
exports.IpAddress = IpAddress;
var Ipv4Address = /** @class */ (function (_super) {
    __extends(Ipv4Address, _super);
    function Ipv4Address(bytes) {
        return _super.call(this, bytes) || this;
    }
    Ipv4Address.prototype.version = function () {
        return '4';
    };
    Ipv4Address.prototype.regularNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.regularNotationV4(this.bytes);
    };
    Ipv4Address.prototype.shortNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.shortNotationV4(this.bytes);
    };
    Ipv4Address.prototype.fullNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.fullNotationV4(this.bytes);
    };
    return Ipv4Address;
}(IpAddress));
exports.Ipv4Address = Ipv4Address;
var Ipv6Address = /** @class */ (function (_super) {
    __extends(Ipv6Address, _super);
    function Ipv6Address(bytes) {
        return _super.call(this, bytes) || this;
    }
    Ipv6Address.prototype.version = function () {
        return '6';
    };
    Ipv6Address.prototype.regularNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.regularNotationV6(this.bytes);
    };
    Ipv6Address.prototype.shortNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.shortNotationV6(this.bytes);
    };
    Ipv6Address.prototype.fullNotation = function () {
        return ip_notation_utils_1.IpNotationUtils.fullNotationV6(this.bytes);
    };
    return Ipv6Address;
}(IpAddress));
exports.Ipv6Address = Ipv6Address;
var Cidr = /** @class */ (function () {
    function Cidr(prefix, prefixLen) {
        this.checkArgs(prefix, prefixLen);
        this.prefix = prefix;
        this.prefixLen = prefixLen;
    }
    Cidr.prototype.checkArgs = function (prefix, prefixLen) {
        if (!prefix) {
            throw new Error('prefix is required');
        }
        if (prefixLen === undefined || prefixLen === null) {
            throw new Error('prefix length is required');
        }
        if (prefix.version() == 'ipv4') {
            if (prefixLen < 0 || prefixLen > ip_notation_utils_1.IPV4_BYTE_COUNT * 8) {
                throw new Error('Invalid prefix length for IPv4');
            }
        }
        else {
            if (prefixLen < 0 || prefixLen > ip_notation_utils_1.IPV6_BYTE_COUNT * 8) {
                throw new Error('Invalid prefix length for IPv6');
            }
        }
    };
    Cidr.prototype.toString = function () {
        return "".concat(this.prefix, "/").concat(this.prefixLen);
    };
    Cidr.prototype.toIpRange = function () {
        var startIpBytes = this.prefix.toByteArray();
        var endIpBytes = startIpBytes.slice(0);
        var masks = byte_array_utils_1.ByteArrayUtils.createMasks(startIpBytes.length, this.prefixLen);
        for (var i = 0; i < startIpBytes.length; ++i) {
            startIpBytes[i] = startIpBytes[i] & masks[i];
            endIpBytes[i] = endIpBytes[i] | (~masks[i] & 0xff);
        }
        return new IpRange(IpAddress.fromByteArray(startIpBytes), IpAddress.fromByteArray(endIpBytes));
    };
    return Cidr;
}());
exports.Cidr = Cidr;
var IpRange = /** @class */ (function () {
    function IpRange(startIpAddr, endIpAddr) {
        this.checkArgs(startIpAddr, endIpAddr);
        this.startIpAddr = startIpAddr;
        this.endIpAddr = endIpAddr;
    }
    IpRange.prototype.checkArgs = function (startIpAddr, endIpAddr) {
        if (!startIpAddr) {
            throw new Error('Start IP address is required');
        }
        if (!endIpAddr) {
            throw new Error('End IP address is required');
        }
        if (startIpAddr.version() !== endIpAddr.version()) {
            throw new Error('Start and end IP addresses must both be IPv4 or IPv6');
        }
        if (startIpAddr.compareTo(endIpAddr) > 0) {
            throw new Error('Start IP address must not be greater than end IP address');
        }
    };
    IpRange.prototype.toString = function () {
        return "".concat(this.startIpAddr, " - ").concat(this.endIpAddr);
    };
    IpRange.prototype.toCidrs = function () {
        var cidrs = new Array();
        var startIpBytes = this.startIpAddr.toByteArray();
        var endIpBytes = this.endIpAddr.toByteArray();
        var currIpBytes = startIpBytes;
        while (true) {
            var prefixLen = byte_array_utils_1.ByteArrayUtils.findPrefixLengthOfMaxStartingCidr(currIpBytes, endIpBytes);
            var currCidr = new Cidr(IpAddress.fromByteArray(currIpBytes), prefixLen);
            cidrs.push(currCidr);
            var lastIpBytes = currCidr.toIpRange().endIpAddr.toByteArray();
            if (byte_array_utils_1.ByteArrayUtils.compare(lastIpBytes, endIpBytes) >= 0) {
                break;
            }
            currIpBytes = byte_array_utils_1.ByteArrayUtils.plusOne(lastIpBytes);
        }
        return cidrs;
    };
    return IpRange;
}());
exports.IpRange = IpRange;
var IpParseUtils = /** @class */ (function () {
    function IpParseUtils() {
    }
    IpParseUtils.fromString = function (ipString) {
        return this.fromByteArray(this.ipStringToByteArray(ipString));
    };
    IpParseUtils.fromByteArray = function (bytes) {
        if (bytes.length === ip_notation_utils_1.IPV4_BYTE_COUNT) {
            byte_array_utils_1.ByteArrayUtils.validate(bytes, ip_notation_utils_1.IPV4_BYTE_COUNT);
            return new Ipv4Address(bytes);
        }
        else if (bytes.length === ip_notation_utils_1.IPV6_BYTE_COUNT) {
            byte_array_utils_1.ByteArrayUtils.validate(bytes, ip_notation_utils_1.IPV6_BYTE_COUNT);
            return new Ipv6Address(bytes);
        }
        else {
            throw new Error("invalid byte array length: ".concat(bytes.length));
        }
    };
    IpParseUtils.ipStringToByteArray = function (ipString) {
        // Make a first pass to categorize the characters in this string.
        var hasColon = false;
        var hasDot = false;
        for (var i = 0; i < ipString.length; i++) {
            var c = ipString.charAt(i);
            if (c === '.') {
                hasDot = true;
            }
            else if (c === ':') {
                if (hasDot) {
                    throw new Error('Colons must not appear after dots');
                }
                hasColon = true;
            }
            else if (!this.isHexDigit(c)) {
                throw new Error("Invalid character found: ".concat(c));
            }
        }
        // Now decide which address family to parse.
        if (hasColon) {
            if (hasDot) {
                ipString = this.convertDottedQuadToHex(ipString);
            }
            return this.textToNumericFormatV6(ipString);
        }
        else if (hasDot) {
            return this.textToNumericFormatV4(ipString);
        }
        throw new Error("'".concat(ipString, " is not an IP string literal"));
    };
    IpParseUtils.convertDottedQuadToHex = function (ipString) {
        var lastColon = ipString.lastIndexOf(':');
        var initialPart = ipString.substring(0, lastColon + 1);
        var dottedQuad = ipString.substring(lastColon + 1);
        var quad = this.textToNumericFormatV4(dottedQuad);
        var penultimate = byte_array_utils_1.ByteArrayUtils.bytePairToHex(quad[0], quad[1]);
        var ultimate = byte_array_utils_1.ByteArrayUtils.bytePairToHex(quad[2], quad[3]);
        return initialPart + penultimate + ':' + ultimate;
    };
    IpParseUtils.textToNumericFormatV4 = function (ipString) {
        var octets = ipString.split('.');
        if (octets.length !== ip_notation_utils_1.IPV4_PART_COUNT) {
            throw new Error('IPv4 addresses must have exactly 4 octets');
        }
        return octets.map(function (octet) {
            if (octet.length <= 0) {
                throw new Error('Address octets must not be empty');
            }
            if (octet.length > 3) {
                throw new Error('Address octets must contain no more than 3 digits');
            }
            var v = Number(octet);
            if (!Number.isInteger(v)) {
                throw new Error('Address octets must be integer');
            }
            if ((v & 0xffffff00) !== 0) {
                throw new Error('Address octets must be between 0 and 255');
            }
            return v;
        });
    };
    IpParseUtils.textToNumericFormatV6 = function (ipString) {
        // An address can have [2..8] colons, and N colons make N+1 parts.
        var parts = ipString.split(':');
        if (parts.length < 3 || parts.length > ip_notation_utils_1.IPV6_PART_COUNT + 1) {
            throw new Error("Invalid number of colons found: ".concat(parts.length - 1));
        }
        // Disregarding the endpoints, find '::' with nothing in between.
        // This indicates that a run of zeroes has been skipped.
        var skipIndex = -1;
        for (var i = 1; i < parts.length - 1; ++i) {
            if (parts[i].length === 0) {
                if (skipIndex >= 0) {
                    throw new Error('Cannot have more than one ::');
                }
                skipIndex = i;
            }
        }
        var partsHi; // Number of parts to copy from above/before the '::'
        var partsLo; // Number of parts to copy from below/after the '::'
        if (skipIndex >= 0) {
            // If we found a '::', then check if it also covers the endpoints.
            partsHi = skipIndex;
            partsLo = parts.length - skipIndex - 1;
            if (parts[0].length === 0 && --partsHi !== 0) {
                throw new Error('^: found, requires ^::');
            }
            if (parts[parts.length - 1].length === 0 && --partsLo !== 0) {
                throw new Error(':$ found, requires ::$');
            }
        }
        else {
            // Otherwise, allocate the entire address to partsHi. The endpoints
            // could still be empty, but parseNonEmptyPartIntoByteArray() will check for that.
            partsHi = parts.length;
            partsLo = 0;
        }
        // If we found a ::, then we must have skipped at least one part.
        // Otherwise, we must have exactly the right number of parts.
        var partsSkipped = ip_notation_utils_1.IPV6_PART_COUNT - (partsHi + partsLo);
        if (!(skipIndex >= 0 ? partsSkipped >= 1 : partsSkipped === 0)) {
            throw new Error('Invalid number of parts found');
        }
        // Now parse the hextets into a byte array.
        var bytes = new Array(2 * ip_notation_utils_1.IPV6_PART_COUNT);
        bytes.fill(0);
        for (var i = 0; i < partsHi; ++i) {
            this.parseNonEmptyPartIntoByteArray(parts[i], bytes, i * 2);
        }
        for (var i = partsLo; i > 0; --i) {
            this.parseNonEmptyPartIntoByteArray(parts[parts.length - i], bytes, (ip_notation_utils_1.IPV6_PART_COUNT - i) * 2);
        }
        return bytes;
    };
    IpParseUtils.parseNonEmptyPartIntoByteArray = function (part, bytes, loc) {
        if (part.length <= 0) {
            throw new Error('Unexpected empty address part encountered');
        }
        if (part.length > 4) {
            throw new Error('Address parts must contain no more than 4 digits');
        }
        var v = parseInt(part, 16);
        if ((v & 0xffff0000) !== 0) {
            throw new Error("Invalid v6 part found: ".concat(part));
        }
        bytes[loc] = v >> 8;
        bytes[loc + 1] = v & 0xff;
    };
    IpParseUtils.isHexDigit = function (c) {
        return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
    };
    return IpParseUtils;
}());
